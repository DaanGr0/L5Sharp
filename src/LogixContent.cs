using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Xml.Linq;
using System.Xml.Serialization;
using L5Sharp.Attributes;
using L5Sharp.Core;
using L5Sharp.Enums;
using L5Sharp.Extensions;
using L5Sharp.Serialization;
using L5Sharp.Utilities;

namespace L5Sharp
{
    /// <summary>
    /// A simple wrapper around a given <see cref="XElement"/>, which is expected to be the root RSLogix5000Content element
    /// of the L5X file. This class implements <see cref="ILogixContent"/> API.
    /// </summary>
    public class LogixContent : ILogixContent
    {
        private readonly XElement _content;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="element"></param>
        /// <exception cref="ArgumentNullException"></exception>
        private LogixContent(XElement element)
        {
            if (element is null)
                throw new ArgumentNullException(nameof(element));

            if (element.Name != L5XName.RSLogix5000Content)
                throw new ArgumentException($"Expecting root element name of {L5XName.RSLogix5000Content}.");

            _content = element;
        }

        /// <summary>
        /// Creates a new <see cref="LogixContent"/> by loading the contents of the provide file name.
        /// </summary>
        /// <param name="fileName">The full path, including file name, to the L5X file to load.</param>
        /// <returns>A new <see cref="LogixContent"/> containing the contents of the specified file.</returns>
        /// <exception cref="ArgumentException">The string is null or empty.</exception>
        /// <remarks>
        /// This factory method uses the <see cref="XDocument.Load(string)"/> to load the contents of the xml file into
        /// memory. This means that this method is subject to the same exceptions that could be generated by loading the
        /// XDocument. Once loaded, validation is performed to ensure the content adheres to the specified L5X Schema files.
        /// </remarks>
        public static LogixContent Load(string fileName) => new(XElement.Load(fileName));

        /// <summary>
        /// Creates a new <see cref="LogixContent"/> with the provided L5X string content.
        /// </summary>
        /// <param name="text">The string that contains the L5X content to parse.</param>
        /// <returns>A new <see cref="LogixContent"/> containing the contents of the specified string.</returns>
        /// <exception cref="ArgumentException">The string is null or empty.</exception>
        /// <remarks>
        /// This factory method uses the <see cref="XDocument.Parse(string)"/> to load the contents of the xml file into
        /// memory. This means that this method is subject to the same exceptions that could be generated by parsing the
        /// XDocument. Once parsed, validation is performed to ensure the content adheres to the specified L5X Schema files.
        /// </remarks>
        public static LogixContent Parse(string text) => new(XElement.Parse(text));

        /// <summary>
        /// Gets the value of the schema revision for the current L5X content.
        /// </summary>
        /// <value>A <see cref="Revision"/> type that represent the major/minor revision of the L5X schema.</value>
        /// <remarks>This is always 1.0. If the R</remarks>
        public Revision? SchemaRevision => _content.PropertyOrDefault<Revision>(L5XName.SchemaRevision);

        /// <summary>
        /// Gets the value of the software revision for the current L5X content.
        /// </summary>
        /// <value>A <see cref="Revision"/> type that represent the major/minor revision of the software.</value>
        public Revision? SoftwareRevision => _content.PropertyOrDefault<Revision>(L5XName.SoftwareRevision);

        /// <summary>
        /// Gets the name of the Logix component that is the target of the current L5X context.
        /// </summary>
        public string? TargetName => _content.PropertyOrDefault<string>(L5XName.TargetName);

        /// <summary>
        /// Gets the type of Logix component that is the target of the current L5X context.
        /// </summary>
        public string? TargetType => _content.PropertyOrDefault<string>(L5XName.TargetType);

        /// <summary>
        /// Gets the value indicating whether the current L5X is contextual..
        /// </summary>
        public bool? ContainsContext => _content.PropertyOrDefault<bool>(L5XName.ContainsContext);

        /// <summary>
        /// Gets the owner that exported the current L5X file.
        /// </summary>
        public string? Owner => _content.PropertyOrDefault<string>(L5XName.Owner);

        /// <summary>
        /// Gets the date time that the L5X file was exported.
        /// </summary>
        public DateTime? ExportDate => _content.LogixDateTimeOrDefault(L5XName.ExportDate);


        /// <inheritdoc />
        public void Add<TComponent>(TComponent component) where TComponent : ILogixComponent
        {
            var serializer = GetSerializer<TComponent>();
            var elementName = GetElementName<TComponent>();
            _content.Descendants(elementName).Last().AddAfterSelf(serializer.Serialize(component));
        }

        /// <inheritdoc />
        public bool Any<TEntity>()
        {
            var elementName = GetElementName<TEntity>();
            return _content.Descendants(elementName).Any();
        }

        /// <inheritdoc />
        public int Count<TEntity>()
        {
            var elementName = GetElementName<TEntity>();
            return _content.Descendants(elementName).Count();
        }

        /// <inheritdoc />
        public bool Contains<TComponent>(string name) where TComponent : class, ILogixComponent
        {
            var elementName = GetElementName<TComponent>();
            return _content.Descendants(elementName).Any(e => e.Attribute(L5XName.Name)?.Value == name);
        }

        /// <inheritdoc />
        public TComponent? Find<TComponent>(string name) where TComponent : class, ILogixComponent
        {
            var serializer = GetSerializer<TComponent>();
            var elementName = GetElementName<TComponent>();
            var result = _content.Descendants(elementName)
                .SingleOrDefault(e => e.Attribute(L5XName.Name)?.Value == name);
            return result is not null ? serializer.Deserialize(result) : null;
        }

        /// <inheritdoc />
        public IEnumerable<TEntity> GetAll<TEntity>()
        {
            var serializer = GetSerializer<TEntity>();
            var elementName = GetElementName<TEntity>();
            return _content.Descendants(elementName).Select(e => serializer.Deserialize(e));
        }

        /// <inheritdoc />
        public TComponent Get<TComponent>(string name) where TComponent : class, ILogixComponent
        {
            var serializer = GetSerializer<TComponent>();
            var elementName = GetElementName<TComponent>();
            var result = _content.Descendants(elementName).Single(e => e.Attribute(L5XName.Name)?.Value == name);
            return serializer.Deserialize(result);
        }

        /// <inheritdoc />
        public void Remove<TComponent>(string name) where TComponent : class, ILogixComponent
        {
            var elementName = GetElementName<TComponent>();
            var component = _content.Descendants(elementName)
                .FirstOrDefault(c => c.Attribute(L5XName.Name)?.Value == name);
            component?.Remove();
        }

        /// <inheritdoc />
        public ILogixScopedContent IsScope(Scope scope, string? scopeName = null)
        {
            throw new NotImplementedException();
        }

        /// <inheritdoc />
        public ILogixScopedContent InProgram(string programName)
        {
            throw new NotImplementedException();
        }

        /// <inheritdoc />
        public ILogixScopedContent InRoutine(string routineName, string? programName)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Serialize this <see cref="LogixContent"/> to a file, overwriting an existing file, if it exists.
        /// </summary>
        /// <param name="fileName">A string that contains the name of the file.</param>
        public void Save(string fileName)
        {
            var declaration = new XDeclaration("1.0", "UTF-8", "yes");
            var document = new XDocument(declaration);
            document.Add(_content);
            document.Save(fileName);
        }

        /// <inheritdoc />
        public override string ToString() => _content.ToString();

        /// <summary>
        /// Returns a new <see cref="XElement"/> instance containing the XML of the current <see cref="LogixContent"/> file. 
        /// </summary>
        /// <returns>A <see cref="XElement"/> representing the Logix content.</returns>
        /// <remarks>This allows easy access to the underlying raw L5X data. This can be used to further extend
        /// the <see cref="LogixContent"/> by creating static query methods that perform custom filtering and
        /// deserialization of the L5X.</remarks>
        public XElement ToElement() => new(_content);

        private static string GetElementName<TEntity>()
        {
            var attribute = typeof(TEntity).GetCustomAttribute<XmlTypeAttribute>();

            return attribute is not null ? attribute.TypeName : typeof(TEntity).Name;
        }

        private static ILogixSerializer<TEntity> GetSerializer<TEntity>()
        {
            var attribute = typeof(TEntity).GetCustomAttribute<LogixSerializerAttribute>();

            if (attribute is null)
                throw new InvalidOperationException(
                    @$"No serializer defined for type {typeof(TEntity)}.
                     Class must specify LogixSerializerAttribute to be deserialized.");

            var serializer = Activator.CreateInstance(attribute.Type);

            if (serializer is not ILogixSerializer<TEntity> logixSerializer)
                throw new InvalidOperationException(
                    @$"The serializer {attribute.Type} is does not serialize objects of type {typeof(TEntity)}.
                    Either specify correct LogixSerializerAttribute for type ");

            return logixSerializer;
        }

        private static XElement CreateContent<TComponent>(TComponent target) where TComponent : ILogixComponent
        {
            var content = new XElement(L5XName.RSLogix5000Content);

            content.Add(new XAttribute(L5XName.SchemaRevision, new Revision().ToString()));
            content.Add(new XAttribute(L5XName.TargetName, target.Name));
            content.Add(new XAttribute(L5XName.TargetType, target.GetType()));
            content.Add(new XAttribute(L5XName.ContainsContext, target.Name != L5XName.Controller));
            content.Add(new XAttribute(L5XName.Owner, Environment.UserName));
            //content.Add(new XAttribute(L5XName.ExportDate, DateTime.Now.ToString(DateFormat)));

            //todo this would depend on the component. data type, instruction, module, program, etc...
            var serializer = GetSerializer<TComponent>();
            var component = serializer.Serialize(target);
            content.Add(component);

            return content;
        }
    }
}