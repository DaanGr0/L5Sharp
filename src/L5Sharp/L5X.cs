using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using L5Sharp.Common;
using L5Sharp.Components;
using L5Sharp.Elements;
using L5Sharp.Enums;
using L5Sharp.Utilities;

namespace L5Sharp;

/// <summary>
/// This is the primary entry point for interacting with the L5X file.
/// Provides access to query and manipulate logix components, elements, containers, and more. 
/// </summary>
/// <remarks>
/// </remarks>
public class L5X : ILogixSerializable
{
    /// <summary>
    /// The date/time format for the L5X content.
    /// </summary>
    public const string DateTimeFormat = "ddd MMM d HH:mm:ss yyyy";

    /// <summary>
    /// The underlying root RSLogix5000Content element of the L5X file.
    /// </summary>
    private readonly XElement _content;

    /// <summary>
    /// An index of all logix components in the L5X file for fast lookups.
    /// </summary>
    private readonly Dictionary<string, ComponentItem> _componentIndex = new();

    /// <summary>
    /// An index of all logix component references in the L5X file for fast lookups.
    /// </summary>
    private readonly Dictionary<string, List<XElement>> _referenceIndex = new();

    /// <summary>
    /// The list of top level component containers for a L5X content or controller element in order of which
    /// they should appear in the L5X file.
    /// </summary>
    private static readonly List<string> Containers = new()
    {
        L5XName.DataTypes,
        L5XName.Modules,
        L5XName.AddOnInstructionDefinitions,
        L5XName.Tags,
        L5XName.Programs,
        L5XName.Tasks,
        L5XName.ParameterConnections,
        L5XName.Trends,
        L5XName.QuickWatchLists
    };

    /// <summary>
    /// The list of all component types for a L5X file. 
    /// </summary>
    private static readonly List<string> Components = new()
    {
        L5XName.AddOnInstructionDefinition,
        L5XName.DataType,
        L5XName.Module,
        L5XName.Program,
        L5XName.Routine,
        L5XName.Tag,
        L5XName.Task,
        L5XName.Trend,
        L5XName.QuickWatchList
    };

    /// <summary>
    /// Creates a new <see cref="L5X"/> instance wrapping the provided <see cref="XElement"/> content object.
    /// </summary>
    /// <param name="content">The root <see cref="XElement"/> object representing the RSLogix5000Content element of the
    /// L5X file.</param>
    /// <exception cref="ArgumentNullException"><c>content</c> is null.</exception>
    /// <exception cref="ArgumentException"><c>content</c> name is not expected <c>RSLogix5000Content</c>.</exception>
    public L5X(XElement content)
    {
        if (content is null)
            throw new ArgumentNullException(nameof(content));

        if (content.Name != L5XName.RSLogix5000Content)
            throw new ArgumentException(
                $"Expecting root element name of {L5XName.RSLogix5000Content} to initialize L5X.");

        _content = content;

        // We will "normalize" (ensure consistent root controller element and component containers) for all
        // files so that we won't have issues getting top level containers. When saving we can remove unused containers.
        Normalize();

        IndexComponents();
        //IndexReferences();

        //This stores L5X object as in-memory object for the root XElement,
        //allowing child elements to retrieve the object locally without creating a new instance.
        //This allows them to reference to root L5X for index or other operations without having new instantiate a new object.
        _content.AddAnnotation(this);
    }

    /// <summary>
    /// Creates a new <see cref="L5X"/> by loading the contents of the provide file name.
    /// </summary>
    /// <param name="fileName">The full path, including file name, to the L5X file to load.</param>
    /// <returns>A new <see cref="L5X"/> containing the contents of the specified file.</returns>
    /// <exception cref="ArgumentException">The string is null or empty.</exception>
    /// <remarks>
    /// This factory method uses the <see cref="XDocument.Load(string)"/> to load the contents of the xml file into
    /// memory. This means that this method is subject to the same exceptions that could be generated by loading the
    /// XDocument. Once loaded, validation is performed to ensure the content adheres to the specified L5X Schema files.
    /// </remarks>
    public static L5X Load(string fileName) => new(XElement.Load(fileName));

    //todo finish this
    public static L5X Export<TComponent>(TComponent component) where TComponent : LogixComponent<TComponent>
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="name"></param>
    /// <param name="processor"></param>
    /// <param name="revision"></param>
    /// <returns></returns>
    public static L5X New(string name, string processor, Revision? revision) =>
        new(NewContent(name, nameof(Controller), revision));

    /// <summary>
    /// Creates a new <see cref="L5X"/> with the provided L5X string content.
    /// </summary>
    /// <param name="text">The string that contains the L5X content to parse.</param>
    /// <returns>A new <see cref="L5X"/> containing the contents of the specified string.</returns>
    /// <exception cref="ArgumentException">The string is null or empty.</exception>
    /// <remarks>
    /// This factory method uses the <see cref="XDocument.Parse(string)"/> to load the contents of the xml file into
    /// memory. This means that this method is subject to the same exceptions that could be generated by parsing the
    /// XDocument. Once parsed, validation is performed to ensure the content adheres to the specified L5X Schema files.
    /// </remarks>
    public static L5X Parse(string text) => new(XElement.Parse(text));

    /// <summary>
    /// The <see cref="L5XInfo"/> representing the L5X content export information.
    /// </summary>
    public L5XInfo Info => new(_content);

    /// <summary>
    /// The root <see cref="Components.Controller"/> component of the L5X file.
    /// </summary>
    /// <value>A <see cref="Components.Controller"/> component object.</value>
    /// <remarks>If the L5X does not <c>ContainContext</c>, meaning it is a project export, this will container all the
    /// relevant controller properties and configurations. Otherwise most data will be null as the controller serves as
    /// just a root container for other component objects.</remarks>
    public Controller Controller => new(GetController());

    /// <summary>
    /// The container collection of <see cref="DataType"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="DataType"/> components.</value>
    public LogixContainer<DataType> DataTypes => new(GetContainer(L5XName.DataTypes));

    /// <summary>
    /// Gets the collection of <see cref="AddOnInstruction"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="AddOnInstruction"/> components.</value>
    public LogixContainer<AddOnInstruction> Instructions => new(GetContainer(L5XName.AddOnInstructionDefinitions));

    /// <summary>
    /// Gets the collection of <see cref="Module"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Module"/> components.</value>
    public LogixContainer<Module> Modules => new(GetContainer(L5XName.Modules));

    /// <summary>
    /// Gets the collection of Controller <see cref="Tags"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Tags"/> components.</value>
    /// <remarks>To access program specific tag collection user the <see cref="Programs"/> collection.</remarks>
    public LogixContainer<Tag> Tags => new(GetContainer(L5XName.Tags));

    /// <summary>
    /// Gets the collection of <see cref="Program"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Program"/> components.</value>
    public LogixContainer<Program> Programs => new(GetContainer(L5XName.Programs));

    /// <summary>
    /// Gets the collection of <see cref="Task"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Task"/> components.</value>
    public LogixContainer<Task> Tasks => new(GetContainer(L5XName.Tasks));

    /// <summary>
    /// The container collection of <see cref="ParameterConnection"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="ParameterConnection"/> components.</value>
    public LogixContainer<ParameterConnection> ParameterConnections =>
        new(GetContainer(L5XName.ParameterConnections));

    /// <summary>
    /// The container collection of <see cref="Trend"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Trend"/> components.</value>
    public LogixContainer<Trend> Trends => new(GetContainer(L5XName.Trends));

    /// <summary>
    /// The container collection of <see cref="WatchList"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="WatchList"/> components.</value>
    public LogixContainer<WatchList> WatchLists => new(GetContainer(L5XName.QuickWatchLists));

    /// <summary>
    /// Finds elements of the specified type across the entire L5X and returns as a flat <see cref="IEnumerable{T}"/> of objects.
    /// </summary>
    /// <typeparam name="TElement">The element type to find.</typeparam>
    /// <returns>A <see cref="IEnumerable{T}"/> containing all found objects of the specified type.</returns>
    public IEnumerable<TElement> Find<TElement>() where TElement : LogixElement =>
        _content.Descendants(typeof(TElement).L5XType()).Select(LogixSerializer.Deserialize<TElement>);

    /// <summary>
    /// Merges the specified L5X file with the current <see cref="L5X"/> L5X by adding or overwriting logix components.
    /// </summary>
    /// <param name="fileName">The file name of L5X to merge.</param>
    /// <param name="overwrite">A bit indicating whether to overwrite incoming components of the same name.</param>
    /// <exception cref="ArgumentException"><c>fileName</c> is null or empty.</exception>
    public void Import(string fileName, bool overwrite = true)
    {
        if (string.IsNullOrEmpty(fileName))
            throw new ArgumentException("FileName can not be null or empty.", nameof(fileName));
        var content = Load(fileName);
        Import(content, overwrite);
    }

    /// <summary>
    /// Merges another <see cref="L5X"/> file into the current L5X by adding or overwriting logix components.
    /// </summary>
    /// <param name="content">The <see cref="L5X"/> to merge.</param>
    /// <param name="overwrite">A bit indicating whether to overwrite incoming components of the same name.</param>
    /// <exception cref="ArgumentNullException"><c>content</c> is null.</exception>
    public void Import(L5X content, bool overwrite = true)
    {
        if (content is null) throw new ArgumentNullException(nameof(content));
        MergeContent(content, overwrite);
    }

    /// <summary>
    /// Serialize this <see cref="L5X"/> to a file, overwriting an existing file, if it exists.
    /// </summary>
    /// <param name="fileName">A string that contains the name of the file.</param>
    public void Save(string fileName) => SaveContent(fileName);

    /// <inheritdoc />
    public XElement Serialize() => _content;

    /// <inheritdoc />
    public override string ToString() => _content.ToString();


    /// <summary>
    /// Gets a top level container element from the root controller element of the L5X.
    /// </summary>
    /// <param name="name">The name of the container to retrieve.</param>
    /// <returns>A <see cref="XElement"/> representing the container with the provided name.</returns>
    /// <exception cref="InvalidOperationException">The element does not exist.</exception>
    private XElement GetContainer(string name) => GetController().Element(name) ?? throw _content.L5XError(name);

    /// <summary>
    /// Gets all primary/top level L5X component containers in the current L5X file.
    /// </summary>
    /// <returns>A <see cref="IEnumerable{T}"/> of <see cref="XElement"/> representing the L5X component containers.</returns>
    private IEnumerable<XElement> GetContainers() => Containers.Select(name => GetController().Element(name)).ToList();

    /// <summary>
    /// Gets the root controller element of the L5X file. We expect this to always exist if the L5X is constructed
    /// due to the normalization process. 
    /// </summary>
    private XElement GetController() =>
        _content.Element(L5XName.Controller) ?? throw _content.L5XError(L5XName.Controller);

    /// <summary>
    /// Merges all top level containers and their immediate child elements between the current L5X content and the
    /// provided L5X content. Will overwrite if specified.
    /// </summary>
    /// <param name="l5X">The L5X element to merge with the current target element.</param>
    /// <param name="overwrite">A flag to indicate whether to overwrite child elements of matching name.</param>
    private void MergeContent(L5X l5X, bool overwrite)
    {
        var containerPairs = GetContainers()
            .Join(l5X.GetContainers(), e => e.Name, e => e.Name, (a, b) => new {a, b})
            .ToList();

        foreach (var pair in containerPairs)
            MergeContainers(pair.a, pair.b, overwrite);
    }

    /// <summary>
    /// Given to top level containers, adds or replaces all child elements matching based on the logix name of the elements.
    /// </summary>
    private static void MergeContainers(XContainer target, XContainer source, bool overwrite)
    {
        foreach (var element in source.Elements())
        {
            var match = target.Elements().FirstOrDefault(e => e.LogixName() == element.LogixName());

            if (match is null)
            {
                target.Add(element);
                continue;
            }

            if (overwrite)
                match.ReplaceWith(element);
        }
    }

    /// <summary>
    /// If no root controller element exists, adds new context controller and moves all root elements into that controller
    /// element. Then adds missing top level containers to ensure consistent structure of the root L5X.
    /// </summary>
    private void Normalize()
    {
        if (_content.Element(L5XName.Controller) is null)
        {
            var context = new XElement(L5XName.Controller, new XAttribute(L5XName.Use, Use.Context));
            context.Add(_content.Elements());
            _content.RemoveNodes();
            _content.Add(context);
        }

        var controller = _content.Element(L5XName.Controller)!;

        foreach (var container in from container in Containers
                 let existing = controller.Element(container)
                 where existing is null
                 select container)
        {
            controller.Add(new XElement(container));
        }
    }

    private static XElement NewContent(string targetName, string targetType, Revision? softwareRevision)
    {
        var content = new XElement(L5XName.RSLogix5000Content);
        content.Add(new XAttribute(L5XName.SchemaRevision, new Revision()));
        if (softwareRevision is not null) content.Add(new XAttribute(L5XName.SoftwareRevision, softwareRevision));
        content.Add(new XAttribute(L5XName.TargetName, targetName));
        content.Add(new XAttribute(L5XName.TargetType, targetType));
        content.Add(new XAttribute(L5XName.ContainsContext, targetType != nameof(Controller)));
        content.Add(new XAttribute(L5XName.Owner, Environment.UserName));
        content.Add(new XAttribute(L5XName.ExportDate, DateTime.Now.ToString(DateTimeFormat)));

        return content;
    }

    /// <summary>
    /// Create document, adds default declaration, and saves the current L5X content to the specified file name.
    /// </summary>
    /// <param name="fileName">A string that contains the name of the file.</param>
    private void SaveContent(string fileName)
    {
        //This will sanitize containers that were perhaps added when normalizing that went unused.
        foreach (var container in GetContainers().Where(c => !c.HasElements))
            container.Remove();

        var declaration = new XDeclaration("1.0", "UTF-8", "yes");
        var document = new XDocument(declaration);
        document.Add(_content);
        document.Save(fileName);
    }

    #region Indexing

    /// <summary>
    /// Finds all logix component elements and indexes them into a local dictionary for fast lookups.
    /// </summary>
    private void IndexComponents()
    {
        var nonScopedComponents = Components.Where(c => c is not (L5XName.Tag or L5XName.Routine));
        var descendants = _content.Descendants().Where(d =>
            nonScopedComponents.Any(c => c == d.Name.LocalName) && d.Attribute(L5XName.Name) is not null);

        foreach (var descendant in descendants)
        {
            var item = new ComponentItem(descendant);
            if (!_componentIndex.TryAdd(item.Key, item))
                throw new InvalidOperationException($"Duplicate component found: {item.Key}");
        }

        var scopedComponents = new List<string>
        {
            L5XName.Tag, L5XName.ConfigTag, L5XName.InputTag, L5XName.OutputTag, L5XName.Routine
        };

        //todo index tags and routines
    }


    private void IndexReferences()
    {
        foreach (var descendant in _content.Descendants())
        {
            // ReSharper disable once ForeachCanBePartlyConvertedToQueryUsingAnotherGetEnumerator
            // Prefer loop for debugging.
            foreach (var component in _componentIndex)
            {
                if (!descendant.ShallowValue().Contains(component.Key) &&
                    !descendant.Attributes().Any(a => a.Value.Contains(component.Key))) continue;

                if (!_referenceIndex.TryAdd(component.Key, new List<XElement> {descendant}))
                    _referenceIndex[component.Key].Add(descendant);
            }
        }
    }

    /// <summary>
    /// The data needed to retrieve and identify a component. Used of indexing and referencing.
    /// </summary>
    private class ComponentItem
    {
        public ComponentItem(XElement element)
        {
            if (element is null) throw new ArgumentNullException(nameof(element));
            Type = element.Name.LocalName;
            Scope = Scope.FromElement(element);
            Container = element.Ancestors(Scope.Name).FirstOrDefault()?.LogixName() ?? string.Empty;
            Name = element.LogixName();
            Element = element;
        }

        public string Key => Container.IsEmpty() ? $"[{Type}]{Name}" : $"[{Type}:{Container}]{Name}";
        public string Type { get; }
        public string Container { get; }
        public Scope Scope { get; }
        public string Name { get; }
        public XElement Element { get; }

        public override string ToString() => Key;

        public override bool Equals(object? obj)
        {
            if (ReferenceEquals(this, obj)) return true;

            return obj switch
            {
                ComponentItem other => string.Equals(Key, other.Key, StringComparison.OrdinalIgnoreCase),
                _ => false
            };
        }

        public override int GetHashCode() => Key.GetHashCode();
    }

    #endregion
}