using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using JetBrains.Annotations;
using L5Sharp.Common;
using L5Sharp.Components;
using L5Sharp.Elements;
using L5Sharp.Enums;
using L5Sharp.Utilities;

namespace L5Sharp;

/// <summary>
/// This is the primary entry point for interacting with the L5X file.
/// Provides access to query and manipulate logix components, elements, containers, and more. 
/// </summary>
/// <remarks>
/// </remarks>
public class L5X : ILogixSerializable
{
    /// <summary>
    /// The date/time format for the L5X content.
    /// </summary>
    public const string DateTimeFormat = "ddd MMM d HH:mm:ss yyyy";

    /// <summary>
    /// The underlying root RSLogix5000Content element of the L5X file.
    /// </summary>
    private readonly XElement _content;

    /// <summary>
    /// An index of all logix components in the L5X file for fast lookups.
    /// </summary>
    private readonly Dictionary<ComponentKey, Dictionary<string, XElement>> _componentIndex = new();

    /// <summary>
    /// An index of all references to a logix component in the L5X file for fast lookups.
    /// </summary>
    private readonly Dictionary<ComponentKey, List<CrossReference>> _referenceIndex = new();

    /// <summary>
    /// The list of top level component containers for a L5X content or controller element in order of which
    /// they should appear in the L5X file.
    /// </summary>
    private static readonly List<string> Containers = new()
    {
        L5XName.DataTypes,
        L5XName.Modules,
        L5XName.AddOnInstructionDefinitions,
        L5XName.Tags,
        L5XName.Programs,
        L5XName.Tasks,
        L5XName.ParameterConnections,
        L5XName.Trends,
        L5XName.QuickWatchLists
    };

    /// <summary>
    /// Creates a new <see cref="L5X"/> instance wrapping the provided <see cref="XElement"/> content object.
    /// </summary>
    /// <param name="content">The root <see cref="XElement"/> object representing the RSLogix5000Content element of the
    /// L5X file.</param>
    /// <exception cref="ArgumentNullException"><c>content</c> is null.</exception>
    /// <exception cref="ArgumentException"><c>content</c> name is not expected <c>RSLogix5000Content</c>.</exception>
    public L5X(XElement content)
    {
        if (content is null)
            throw new ArgumentNullException(nameof(content));

        if (content.Name != L5XName.RSLogix5000Content)
            throw new ArgumentException(
                $"Expecting root element name of {L5XName.RSLogix5000Content} to initialize L5X.");

        _content = content;

        //We will "normalize" (ensure consistent root controller element and component containers) for all
        //files so that we won't have issues getting top level containers. When saving we can remove unused containers.
        NormalizeContent();

        //Index all components for quick lookup from child elements or from top level L5X.
        IndexComponents();
        IndexReferences();

        //Detect changes to keep index up to date.
        _content.Changing += OnContentChanging;
        _content.Changed += OnContentChanged;

        //This stores L5X object as in-memory object for the root XElement,
        //allowing child elements to retrieve the object locally without creating a new instance (and reindexing of content).
        //This allows them to reference to root L5X for cross referencing or other operations.
        _content.AddAnnotation(this);
    }

    /// <summary>
    /// Creates a new <see cref="L5X"/> by loading the contents of the provide file name.
    /// </summary>
    /// <param name="fileName">The full path, including file name, to the L5X file to load.</param>
    /// <returns>A new <see cref="L5X"/> containing the contents of the specified file.</returns>
    /// <exception cref="ArgumentException">The string is null or empty.</exception>
    /// <remarks>
    /// This factory method uses the <see cref="XElement.Load(string)"/> to load the contents of the XML file into
    /// memory. This means that this method is subject to the same exceptions that could be generated by loading the
    /// XElement.
    /// </remarks>
    public static L5X Load(string fileName) => new(XElement.Load(fileName));

    /// <summary>
    /// Creates a new <see cref="L5X"/> file with the standard root content and controller elements, and configures them
    /// with the provided controller name, processor, and revision. 
    /// </summary>
    /// <param name="name">The name of the controller.</param>
    /// <param name="processor">The processor catalog number.</param>
    /// <param name="revision">The optional software revision of the processor.</param>
    /// <returns>A new default <see cref="L5X"/> with the specified controller properties.</returns>
    public static L5X New(string name, string processor, Revision? revision) =>
        new(NewContent(name, nameof(Controller), revision));

    /// <summary>
    /// 
    /// </summary>
    /// <param name="component"></param>
    /// <param name="revision"></param>
    /// <typeparam name="TComponent"></typeparam>
    /// <returns></returns>
    public static L5X New<TComponent>(TComponent component, Revision? revision = null)
        where TComponent : LogixComponent => new(NewContent(component.Name, typeof(TComponent).L5XType(), revision));

    /// <summary>
    /// Creates a new <see cref="L5X"/> with the provided L5X string content.
    /// </summary>
    /// <param name="text">The string that contains the L5X content to parse.</param>
    /// <returns>A new <see cref="L5X"/> containing the contents of the specified string.</returns>
    /// <exception cref="ArgumentException">The string is null or empty.</exception>
    /// <remarks>
    /// This factory method uses the <see cref="XElement.Parse(string)"/> to load the contents of the XML file into
    /// memory. This means that this method is subject to the same exceptions that could be generated by parsing the
    /// XElement.
    /// </remarks>
    public static L5X Parse(string text) => new(XElement.Parse(text));

    /// <summary>
    /// The <see cref="L5XInfo"/> representing the L5X content export information.
    /// </summary>
    public L5XInfo Info => new(_content);

    /// <summary>
    /// The root <see cref="Components.Controller"/> component of the L5X file.
    /// </summary>
    /// <value>A <see cref="Components.Controller"/> component object.</value>
    /// <remarks>If the L5X does not <c>ContainContext</c>, meaning it is a project export, this will contain all the
    /// relevant controller properties and configurations. Otherwise most data will be null as the controller serves as
    /// just a root container for other component objects.</remarks>
    public Controller Controller => new(GetController());

    /// <summary>
    /// The container collection of <see cref="DataType"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="DataType"/> components.</value>
    [PublicAPI]
    public LogixContainer<DataType> DataTypes => new(GetContainer(L5XName.DataTypes));

    /// <summary>
    /// Gets the collection of <see cref="AddOnInstruction"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="AddOnInstruction"/> components.</value>
    [PublicAPI]
    public LogixContainer<AddOnInstruction> Instructions => new(GetContainer(L5XName.AddOnInstructionDefinitions));

    /// <summary>
    /// Gets the collection of <see cref="Module"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Module"/> components.</value>
    public LogixContainer<Module> Modules => new(GetContainer(L5XName.Modules));

    /// <summary>
    /// Gets the collection of Controller <see cref="Tags"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Tags"/> components.</value>
    /// <remarks>To access program specific tag collection user the <see cref="Programs"/> collection.</remarks>
    public LogixContainer<Tag> Tags => new(GetContainer(L5XName.Tags));

    /// <summary>
    /// Gets the collection of <see cref="Program"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Program"/> components.</value>
    public LogixContainer<Program> Programs => new(GetContainer(L5XName.Programs));

    /// <summary>
    /// Gets the collection of <see cref="Task"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Task"/> components.</value>
    public LogixContainer<Task> Tasks => new(GetContainer(L5XName.Tasks));

    /// <summary>
    /// The container collection of <see cref="ParameterConnection"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="ParameterConnection"/> components.</value>
    public LogixContainer<ParameterConnection> ParameterConnections =>
        new(GetContainer(L5XName.ParameterConnections));

    /// <summary>
    /// The container collection of <see cref="Trend"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="Trend"/> components.</value>
    public LogixContainer<Trend> Trends => new(GetContainer(L5XName.Trends));

    /// <summary>
    /// The container collection of <see cref="WatchList"/> components found in the L5X file.
    /// </summary>
    /// <value>A <see cref="LogixContainer{TComponent}"/> of <see cref="WatchList"/> components.</value>
    public LogixContainer<WatchList> WatchLists => new(GetContainer(L5XName.QuickWatchLists));

    /// <summary>
    /// Adds the given logix component to the first found container within the L5X tree. 
    /// </summary>
    /// <param name="component">The component to add to the L5X.</param>
    /// <typeparam name="TComponent">The type of component to add to the L5X.</typeparam>
    /// <exception cref="InvalidOperationException">No container was found in the L5X tree for the specified type.</exception>
    /// <remarks>
    /// This provides a more dynamic way to add content to an L5X file. Note that this only adds to the first
    /// container found of the specific type. If you are adding scoped components such as <c>Tag</c> or <c>Routine</c>
    /// you should be doing so in the context of a <c>Program</c> component.
    /// </remarks>
    public void Add<TComponent>(TComponent component) where TComponent : LogixComponent
    {
        var containerType = typeof(TComponent).L5XContainer();
        var container = GetContainer(containerType);
        container.Add(component.Serialize());
    }

    /// <summary>
    /// Gets the number of elements of the specified type in the L5X.
    /// </summary>
    /// <typeparam name="TElement">The logix element type to get the count for.</typeparam>
    /// <returns>A <see cref="int"/> representing the number of elements of the specified type.</returns>
    public int Count<TElement>() where TElement : LogixElement =>
        _content.Descendants(typeof(TElement).L5XType()).Count();

    /// <summary>
    /// Finds element across the entire L5X with the provided type as a flat collection of object. 
    /// </summary>
    /// <param name="typeName">The type name or element name to retrieve.</param>
    /// <returns>A <see cref="IEnumerable{T}"/> containing all found object with the provided type name.</returns>
    /// <exception cref="ArgumentException"><c>type</c> is null.</exception>
    /// <remarks>
    /// <para>
    /// This methods provides a flexible and simple way to query the entire L5X for a specific type. This method is allows
    /// specifying the type at runtime as opposed the generic type but sacrifices the strong type querying of the
    /// generic counterpart. This method does not make use of any optimized searching, so if you want to find items quickly,
    /// see &lt;c&gt;FindComponent&lt;/c&gt; or &lt;c&gt;FindTag&lt;/c&gt; method.
    /// </para>
    /// <para>
    /// Also note that this will call <c>L5XType</c> extension internally which returns all configured
    /// element name for the provided type. This means the query will return all elements that the type supports.
    /// If you want specific components look at the container properties.
    /// For example <see cref="Tags"/> for controller scoped tag components only.
    /// </para>
    /// </remarks>
    public IEnumerable<LogixElement> Find(string typeName)
    {
        if (string.IsNullOrEmpty(typeName))
            throw new ArgumentNullException(nameof(typeName), "Type is required to retrieve elements from the L5X");

        return _content.Descendants(typeName).Select(e => e.Deserialize());
    }

    /// <summary>
    /// Finds element across the entire L5X with the provided type as a flat collection of object. 
    /// </summary>
    /// <param name="type">The type of the element type to retrieve.</param>
    /// <returns>A <see cref="IEnumerable{T}"/> containing all found object with the provided type name.</returns>
    /// <exception cref="ArgumentException"><c>type</c> is null.</exception>
    /// <remarks>
    /// <para>
    /// This methods provides a flexible and simple way to query the entire L5X for a specific type. This method is allows
    /// specifying the type at runtime as opposed the generic type but sacrifices the strong type querying of the
    /// generic counterpart. This method does not make use of any optimized searching, so if you want to find items quickly,
    /// see &lt;c&gt;FindComponent&lt;/c&gt; or &lt;c&gt;FindTag&lt;/c&gt; method.
    /// </para>
    /// <para>
    /// Also note that this will call <c>L5XType</c> extension internally which returns all configured
    /// element name for the provided type. This means the query will return all elements that the type supports.
    /// If you want specific components look at the container properties.
    /// For example <see cref="Tags"/> for controller scoped tag components only.
    /// </para>
    /// </remarks>
    public IEnumerable<LogixElement> Find(Type type)
    {
        if (type is null)
            throw new ArgumentNullException(nameof(type), "Type is required to retrieve elements from the L5X");

        var typeNames = type.L5XTypes().ToList();

        return _content.Descendants()
            .Where(e => typeNames.Any(n => n.IsEquivalent(e.L5XType())))
            .Select(e => e.Deserialize());
    }

    /// <summary>
    /// Finds elements of the specified type across the entire L5X as a flat collection of objects.
    /// </summary>
    /// <typeparam name="TElement">The element type to find.</typeparam>
    /// <returns>A <see cref="IEnumerable{T}"/> containing all found objects of the specified type.</returns>
    /// <remarks>
    /// This methods provides a flexible and simple way to query the entire L5X for a specific type. Since
    /// it returns an <see cref="IEnumerable{T}"/>, you can make use of LINQ and the strongly typed objects to build
    /// more complex queries. This method does not make use of any optimized searching, so if you want to find items quickly,
    /// see <see cref="FindComponent{TComponent}(string,string)"/> or <see cref="FindTag"/> and <see cref="FindTags"/>.
    /// </remarks>
    public IEnumerable<TElement> Find<TElement>() where TElement : LogixElement
    {
        var typeNames = typeof(TElement).L5XTypes().ToList();

        return _content.Descendants()
            .Where(e => typeNames.Any(n => n.IsEquivalent(e.L5XType())))
            .Select(e => e.Deserialize<TElement>());
    }

    /// <summary>
    /// Finds the first component with the specified name using the internal component index.
    /// </summary>
    /// <param name="name"></param>
    /// <returns>
    /// The first found <see cref="LogixComponent"/> with the specified component name; If none exist, then <c>null</c>.
    /// </returns>
    /// <exception cref="ArgumentException"><c>name</c> is null or empty.</exception>
    /// <remarks>
    /// <para>
    /// Since components have unique names, we can find and index them for fast lookup when needed. There may be more
    /// than one component with the same name in the L5X file (Tags, Routines). This method just returns the first one
    /// found.
    /// </para>
    /// </remarks>
    public LogixComponent? FindComponent(string name)
    {
        if (string.IsNullOrEmpty(name))
            throw new ArgumentException("Name can not be null or empty.", nameof(name));

        var components = ComponentType.All().Select(c => c.Name).ToList();

        return _content.Descendants()
            .FirstOrDefault(e => components.Any(n => n == e.L5XType() && e.LogixName() == name))
            ?.Deserialize<LogixComponent>();
    }

    /// <summary>
    /// Finds the first component with the <see cref="ComponentKey"/> using the internal component index.
    /// </summary>
    /// <param name="key"></param>
    /// <returns>
    /// The first found <see cref="LogixComponent"/> with the specified component key; If none exist, then <c>null</c>.
    /// </returns>
    /// <remarks>
    /// <para>
    /// Since components have unique names, we can find and index them for fast lookup when needed. There may be more
    /// than one component with the same name in the L5X file (Tags, Routines). This method just returns the first one
    /// found.
    /// </para>
    /// </remarks>
    public LogixComponent? FindComponent(ComponentKey key)
    {
        return _componentIndex.TryGetValue(key, out var components)
            ? components.Values.FirstOrDefault()?.Deserialize<LogixComponent>()
            : default;
    }

    /// <summary>
    /// Finds the first component with the specified name and generic type parameter using the internal component index.
    /// </summary>
    /// <param name="name">The name of the component to find.</param>
    /// <typeparam name="TComponent">The type of component to find.</typeparam>
    /// <returns>
    /// The first found <see cref="LogixComponent"/> with the specified component name and type; If none exist, then <c>null</c>.
    /// </returns>
    /// <exception cref="ArgumentException"><c>name</c> is null or empty.</exception>
    /// <remarks>
    /// <para>
    /// Since components have unique names, we can find and index them for fast lookup when needed. There may be more
    /// than one component with the same name in the L5X file (Tags, Routines). This method just returns the first one
    /// found.
    /// </para>
    /// </remarks>
    /// <seealso cref="FindComponent{TComponent}(string)"/>
    public TComponent? FindComponent<TComponent>(string name) where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));

        var key = new ComponentKey(typeof(TComponent).L5XType(), name);

        return _componentIndex.TryGetValue(key, out var components)
            ? (TComponent?)components.Values.FirstOrDefault()?.Deserialize<LogixComponent>()
            : default;
    }

    /// <summary>
    /// Finds a component with the specified component and scope name using the internal component index.
    /// </summary>
    /// <param name="name">The name of the component to find.</param>
    /// <param name="scope">The name of the program in which to search for the component.
    /// This really only applies to tags and routines since they are program scoped components.</param>
    /// <typeparam name="TComponent">The type of component to find.</typeparam>
    /// <returns>
    /// A single <see cref="LogixComponent"/> with the specified component name and scope if found; Otherwise, <c>null</c>.
    /// </returns>
    /// <exception cref="ArgumentException"><c>name</c> or <c>scope</c> is null or empty.</exception>
    /// <remarks>
    /// Since components have unique names, we can find and index them for fast lookup when needed. There may be more
    /// than one component with the same name inf the L5X file (Tags, Routines). This method
    /// returns the single component within the specified scope.
    /// </remarks>
    public TComponent? FindComponent<TComponent>(string name, string scope) where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));
        if (string.IsNullOrEmpty(scope)) throw new ArgumentException("Scope can not be null or empty.", nameof(scope));

        var key = new ComponentKey(typeof(TComponent).L5XType(), name);

        if (_componentIndex.TryGetValue(key, out var components) && components.TryGetValue(scope, out var element))
            element.Deserialize<TComponent>();

        return default;
    }

    /// <summary>
    /// Finds all component with the specified name using the internal component index.
    /// </summary>
    /// <param name="name">The name of the component to find.</param>
    /// <typeparam name="TComponent">The type of component to find.</typeparam>
    /// <returns>
    /// A collection of <see cref="LogixComponent"/> with the specified component name if any are found.
    /// If none are found, an empty collection.
    /// </returns>
    /// <exception cref="ArgumentException"><c>name</c> is null or empty.</exception>
    /// <remarks>
    /// <para>
    /// Since components have unique names, we can find and index them for fast lookup when needed. There may be more
    /// than one component with the same name inf the L5X file (Tags, Routines). This method
    /// returns all components of the specified type and name found in the L5X file.
    /// </para>
    /// </remarks>
    public IEnumerable<TComponent> FindComponents<TComponent>(string name) where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));

        var key = new ComponentKey(typeof(TComponent).L5XType(), name);

        return _componentIndex.TryGetValue(key, out var components)
            ? components.Values.Select(e => e.Deserialize<TComponent>())
            : Enumerable.Empty<TComponent>();
    }

    /// <summary>
    /// Finds all tags with the specified name in the L5X using internal component index.
    /// </summary>
    /// <param name="tagName">The <see cref="TagName"/> of the tag to find in the L5X file.</param>
    /// <param name="scope">The optional scope of the tag to find. If not provided, this will return the first found
    /// object with the provided tag name.</param>
    /// <returns>A <see cref="Tag"/> with the specified tag name and scope if found; Otherwise, <c>null</c>.</returns>
    /// <exception cref="ArgumentNullException"><c>tagName</c> is <c>null</c>.</exception>
    /// <remarks>
    /// The point of this method is to provide an optimized way to retrieve a tag with a specific name in the L5X without
    /// having to iterate all tags in the file, which can be a lot if you consider nested tag members.
    /// This method uses the underlying component index to search for tags.
    /// By default this will return the first found tag with the specified name. You can also specify a scope
    /// name to find a tag within a specific program.
    /// </remarks>
    public Tag? FindTag(TagName tagName, string? scope = null)
    {
        if (tagName is null) throw new ArgumentNullException(nameof(tagName));

        var key = new ComponentKey(typeof(Tag).L5XType(), tagName.Root);

        if (!_componentIndex.TryGetValue(key, out var components))
            return default;

        if (scope is not null)
            return components.TryGetValue(scope, out var element) ? new Tag(element).Member(tagName.Path) : default;

        return components.Values.FirstOrDefault()?.Deserialize<Tag>().Member(tagName.Path);
    }

    /// <summary>
    /// Finds all tags with the specified name in the L5X using internal component index.
    /// </summary>
    /// <param name="tagName">The <see cref="TagName"/> of the tag to find in the L5X file.</param>
    /// <returns>A <see cref="Tag"/> with the specified tag name if found; Otherwise, <c>null</c>.</returns>
    /// <exception cref="ArgumentNullException"><c>tagName</c> is <c>null</c>.</exception>
    /// <remarks>
    /// The point of this method is to provide an optimized way to retrieve a tag with a specific name in the L5X without
    /// having to iterate all tags in the file. This method uses the underlying component index to search for tags.
    /// </remarks>
    public IEnumerable<Tag> FindTags(TagName tagName)
    {
        if (tagName is null) throw new ArgumentNullException(nameof(tagName));

        var key = new ComponentKey(typeof(Tag).L5XType(), tagName.Root);

        return _componentIndex.TryGetValue(key, out var components)
            ? components.Values.Select(t => new Tag(t).Member(tagName.Path)).Where(t => t is not null).Cast<Tag>()
            : Enumerable.Empty<Tag>();
    }

    /// <summary>
    /// Returns all known references to the provided <see cref="LogixComponent"/> instance.
    /// </summary>
    /// <param name="component">The component to find references to.</param>
    /// <returns>A <see cref="IEnumerable{T}"/> containing <see cref="CrossReference"/> objects with the data
    /// pertaining to the element referencing the provided logix component.</returns>
    /// <exception cref="ArgumentNullException"><c>component</c> is <c>null</c>.</exception>
    /// <remarks>
    /// This method calls the internal reference index which is generated upon creation of the L5X.
    /// This allows references to be located quickly without having to iterate all elements in the L5X.
    /// </remarks>
    public IEnumerable<CrossReference> FindReferences(LogixComponent component)
    {
        if (component is null) throw new ArgumentNullException(nameof(component));

        return _referenceIndex.TryGetValue(component.Key, out var references)
            ? references
            : Enumerable.Empty<CrossReference>();
    }

    /// <summary>
    /// Returns all known references to the specified component type and name.
    /// </summary>
    /// <param name="name">The component name to find references to.</param>
    /// <typeparam name="TComponent">The component type to find references for.</typeparam>
    /// <returns>A <see cref="IEnumerable{T}"/> containing <see cref="CrossReference"/> objects with the data
    /// pertaining to the element referencing the provided logix component.</returns>
    /// <exception cref="ArgumentException"><c>name</c> is null or empty.</exception>
    /// <remarks>
    /// This method calls the internal reference index which is generated upon creation of the L5X.
    /// This allows references to be located quickly without having to iterate all elements in the L5X.
    /// </remarks>
    public IEnumerable<CrossReference> FindReferences<TComponent>(string name)
        where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));
        var key = new ComponentKey(typeof(TComponent).L5XType(), name);
        return _referenceIndex.TryGetValue(key, out var references) ? references : Enumerable.Empty<CrossReference>();
    }

    /// <summary>
    /// Gets a component with the specified name using the internal component index.
    /// </summary>
    /// <param name="name">The name of the component to get.</param>
    /// <typeparam name="TComponent">The type of component to get.</typeparam>
    /// <returns>A single <see cref="LogixComponent"/> with the specified component name.</returns>
    /// <exception cref="ArgumentException"><c>name</c> is null or empty.</exception>
    /// <exception cref="KeyNotFoundException">A component with <c>name</c> was not found in the L5X.</exception>
    /// <remarks>
    /// Since components have unique names, we can find and index them for fast lookup when needed. This might
    /// be helpful for certain functions that need to repeatedly find references to other components to perform
    /// certain tasks. Note that the only difference between this method and <see cref="FindComponent{TComponent}(string)"/>
    /// is that this method will throw an exception if the component is not found. Therefore, it also returns a
    /// non-nullable reference type so that the caller can be sure that the component was found.
    /// </remarks>
    public TComponent GetComponent<TComponent>(string name) where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));

        var key = new ComponentKey(typeof(TComponent).L5XType(), name);

        if (!_componentIndex.TryGetValue(key, out var components))
            throw new KeyNotFoundException($"FindComponent not found in L5X: {key}");

        var component = components.Values.SingleOrDefault();
        
        return component is not null
            ? component.Deserialize<TComponent>()
            : throw new KeyNotFoundException($"FindComponent not found in L5X: {key}");
    }

    /// <summary>
    /// Gets a component with the specified name and optional scope name using the internal component index.
    /// </summary>
    /// <param name="name">The name of the component to get.</param>
    /// <param name="scope">The name of the program in which to search for the component.
    /// This really only applies to tags and routines since they are scoped components.</param>
    /// <typeparam name="TComponent">The type of component to find.</typeparam>
    /// <returns>A single <see cref="LogixComponent"/> with the specified component name.</returns>
    /// <exception cref="ArgumentException"><c>name</c> or <c>scope</c> is null or empty.</exception>
    /// <exception cref="KeyNotFoundException">A component with <c>name</c> was not found in the L5X.</exception>
    /// <remarks>
    /// Since components have unique names, we can find and index them for fast lookup when needed. This might
    /// be helpful for certain functions that need to repeatedly find references to other components to perform
    /// certain tasks. Note that the only difference between this method and <see cref="FindComponent{TComponent}(string,string)"/>
    /// is that this method will throw an exception if the component is not found. Therefore, it also returns a
    /// non-nullable reference type so that the caller can be sure that the component was found.
    /// </remarks>
    public TComponent GetComponent<TComponent>(string name, string scope) where TComponent : LogixComponent
    {
        if (string.IsNullOrEmpty(name)) throw new ArgumentException("Name can not be null or empty.", nameof(name));
        if (string.IsNullOrEmpty(scope)) throw new ArgumentException("Scope can not be null or empty.", nameof(scope));

        var key = new ComponentKey(typeof(TComponent).L5XType(), name);

        if (_componentIndex.TryGetValue(key, out var components) && components.TryGetValue(scope, out var element))
            LogixSerializer.Deserialize<TComponent>(element);

        throw new KeyNotFoundException($"FindComponent not found in L5X: {key}");
    }

    /// <summary>
    /// Merges the specified L5X file with the current <see cref="L5X"/> L5X by adding or overwriting logix components.
    /// </summary>
    /// <param name="fileName">The file name of L5X to merge.</param>
    /// <param name="overwrite">A bit indicating whether to overwrite incoming components of the same name.</param>
    /// <exception cref="ArgumentException"><c>fileName</c> is null or empty.</exception>
    public void Import(string fileName, bool overwrite = true)
    {
        if (string.IsNullOrEmpty(fileName))
            throw new ArgumentException("FileName can not be null or empty.", nameof(fileName));
        var content = Load(fileName);
        MergeContent(content, overwrite);
    }

    /// <summary>
    /// Merges another <see cref="L5X"/> file into the current L5X by adding or overwriting logix components.
    /// </summary>
    /// <param name="content">The <see cref="L5X"/> to merge.</param>
    /// <param name="overwrite">A bit indicating whether to overwrite incoming components of the same name.</param>
    /// <exception cref="ArgumentNullException"><c>content</c> is null.</exception>
    public void Import(L5X content, bool overwrite = true)
    {
        if (content is null) throw new ArgumentNullException(nameof(content));
        MergeContent(content, overwrite);
    }

    /// <summary>
    /// Serialize this <see cref="L5X"/> to a file, overwriting an existing file, if it exists.
    /// </summary>
    /// <param name="fileName">A string that contains the name of the file.</param>
    public void Save(string fileName) => SaveContent(fileName);

    /// <inheritdoc />
    public XElement Serialize() => _content;

    /// <inheritdoc />
    public override string ToString() => _content.ToString();

    #region Internal

    /// <summary>
    /// Handles adding a component to the index. This requires the element to be attached to the L5X tree
    /// for it to determine the scope of the element. This will also throw a <see cref="ArgumentException"/>
    /// if the component already exists in the index.
    /// </summary>
    private void AddComponent(XElement element)
    {
        var key = new ComponentKey(element.Name.LocalName, element.LogixName());
        var scope = Scope.ScopeName(element);

        if (_componentIndex.TryAdd(key, new Dictionary<string, XElement> { { scope, element } })) return;
        if (!_componentIndex[key].TryAdd(scope, element))
            throw new ArgumentException($"The provided component '{key}' already exists in {scope}.");
    }

    /// <summary>
    /// Handles adding the provided reference to the index. If no reference exists for the provided key, a new
    /// entry is created, otherwise the reference is added to the existing collection.
    /// </summary>
    private void AddReference(CrossReference reference)
    {
        if (!_referenceIndex.TryAdd(reference.ComponentKey, new List<CrossReference> { reference }))
            _referenceIndex[reference.ComponentKey].Add(reference);
    }

    /// <summary>
    /// Adds the provided collection of references. This is a convenience method to add multiple references.
    /// </summary>
    private void AddReferences(IEnumerable<CrossReference> references)
    {
        foreach (var reference in references)
        {
            AddReference(reference);
        }
    }

    /// <summary>
    /// Handles adding all references to the index that are associated with the provided element.
    /// This is a convenience method since we need to parse the element as an <see cref="ILogixReferencable"/> to
    /// obtain the references to add.
    /// </summary>
    private void AddReferences(XElement element)
    {
        if (element.Deserialize() is not ILogixReferencable referencable) return;
        var references = referencable.References().ToList();
        AddReferences(references);
    }

    /// <summary>
    /// Gets a top level container element from the root controller element of the L5X.
    /// </summary>
    /// <param name="name">The name of the container to retrieve.</param>
    /// <returns>A <see cref="XElement"/> representing the container with the provided name.</returns>
    /// <exception cref="InvalidOperationException">The element does not exist.</exception>
    private XElement GetContainer(string name) => GetController().Element(name) ?? throw _content.L5XError(name);

    /// <summary>
    /// Gets all primary/top level L5X component containers in the current L5X file.
    /// </summary>
    /// <returns>A <see cref="IEnumerable{T}"/> of <see cref="XElement"/> representing the L5X component containers.</returns>
    private IEnumerable<XElement> GetContainers() => Containers.Select(name => GetController().Element(name)).ToList();

    /// <summary>
    /// Gets the root controller element of the L5X file. We expect this to always exist if the L5X is constructed
    /// due to the normalization process. 
    /// </summary>
    private XElement GetController() =>
        _content.Element(L5XName.Controller) ?? throw _content.L5XError(L5XName.Controller);

    /// <summary>
    /// Gets the name of the controller element of the L5X file. Will default to empty string if not found. 
    /// </summary>
    private string GetControllerName() => GetController().LogixName();

    /// <summary>
    /// Finds all logix component elements and indexes them into a local dictionary for fast lookups.
    /// </summary>
    private void IndexComponents()
    {
        IndexControllerScopedComponents();
        IndexProgramScopedComponents();
        IndexModuleDefinedTagComponents();
    }

    /// <summary>
    /// Finds all controller scoped top level components to index. This includes all components except for program tags,
    /// routines, and module defined IO tags, which are handles separately.
    /// </summary>
    private void IndexControllerScopedComponents()
    {
        //The scope for all controller scoped components will be the name of the controller.
        var scope = GetControllerName();

        //Only consider component elements with a valid name attribute. Some components don't have and name and we
        //can't possibly index them.
        var components = GetContainers().SelectMany(c =>
            c.Elements().Where(e => e.Attribute(L5XName.Name) is not null));

        foreach (var component in components)
        {
            var key = new ComponentKey(component.Name.LocalName, component.LogixName());
            if (!_componentIndex.TryAdd(key, new Dictionary<string, XElement> { { scope, component } }))
                _componentIndex[key].TryAdd(scope, component);
            //todo what about collisions?
        }
    }

    /// <summary>
    /// Handles iterating each program component element in the L5X and indexed each tag and routine
    /// with the correct scope.
    /// </summary>
    private void IndexProgramScopedComponents()
    {
        var programs = GetContainer(L5XName.Programs).Elements();

        foreach (var program in programs)
        {
            var scope = program.LogixName();

            foreach (var component in program.Descendants()
                         .Where(d => d.Name.LocalName is L5XName.Tag or L5XName.Routine))
            {
                var key = new ComponentKey(component.Name.LocalName, component.LogixName());
                if (!_componentIndex.TryAdd(key, new Dictionary<string, XElement> { { scope, component } }))
                    _componentIndex[key].TryAdd(scope, component);
                //todo what about collisions?
            }
        }
    }

    /// <summary>
    /// Handles iterating each module defined tag component element in the L5X and indexes each tag.
    /// </summary>
    private void IndexModuleDefinedTagComponents()
    {
        var scope = GetControllerName();

        foreach (var component in GetContainer(L5XName.Modules).Descendants().Where(e =>
                     e.L5XType() is L5XName.ConfigTag or L5XName.InputTag or L5XName.OutputTag))
        {
            var key = new ComponentKey(L5XName.Tag, component.ModuleTagName());
            if (!_componentIndex.TryAdd(key, new Dictionary<string, XElement> { { scope, component } }))
                _componentIndex[key].TryAdd(scope, component);
            //todo what about collisions?
        }
    }

    /// <summary>
    /// Finds all logix reference elements and indexes them into a local dictionary for fast lookups.
    /// </summary>
    private void IndexReferences()
    {
        IndexDataTypeReferences();
        IndexCodeReferences();
    }

    /// <summary>
    /// Finds all elements with a data type attribute and indexes them into a local reference index for fast lookup.
    /// This will include technically any type, predefined, atomic, user defined, or add on instruction.
    /// </summary>
    private void IndexDataTypeReferences()
    {
        var targets = _content.Descendants().Where(d => d.Attribute(L5XName.DataType) is not null);
        foreach (var target in targets)
        {
            var componentName = target.Attribute(L5XName.DataType)!.Value;
            var reference = new CrossReference(target, componentName, L5XName.DataType);
            if (!_referenceIndex.TryAdd(reference.ComponentKey, new List<CrossReference> { reference }))
                _referenceIndex[reference.ComponentKey].Add(reference);
        }
    }

    /// <summary>
    /// Finds all routine content elements, iterates each "code" element, and delegates the retrieval or references to the
    /// materialized logix element object. Then adds each set of references to the reference index for fast lookup.
    /// </summary>
    private void IndexCodeReferences()
    {
        var contentTypes = RoutineType.All().Select(r => r.ContentName).ToList();

        var targets = _content.Descendants().Where(e => contentTypes.Contains(e.Name.LocalName));

        foreach (var target in targets)
        {
            switch (target.Name.LocalName)
            {
                case L5XName.RLLContent:
                    AddReferences(target.Descendants(L5XName.Rung)
                        .SelectMany(x => new Rung(x).References()));
                    break;
                case L5XName.STContent:
                    AddReferences(target.Descendants(L5XName.Line)
                        .SelectMany(x => new Line(x).References()));
                    break;
                case L5XName.FBDContent:
                    AddReferences(target.Descendants(L5XName.Sheet)
                        .SelectMany(x => new Sheet(x).References()));
                    break;
                case L5XName.SFCContent:
                    AddReferences(new Chart(target).References());
                    break;
            }
        }
    }

    /// <summary>
    /// Determines if the provided object is a component element, for which we need to reindex the component.
    /// </summary>
    private static bool IsComponentElement(object sender)
    {
        if (sender is not XElement element) return false;
        var componentTypes = ComponentType.All().Select(c => c.Value).ToList();
        return componentTypes.Contains(element.Name.LocalName);
    }

    /// <summary>
    /// Determines if the provided object is a attribute or property is a component name, for which we need to
    /// reindex the component.
    /// </summary>
    private static bool IsNameProperty(object sender)
    {
        if (sender is not XAttribute attribute) return false;
        if (attribute.Name.LocalName is not L5XName.Name) return false;
        if (attribute.Parent is null) return false;
        var componentTypes = ComponentType.All().Select(c => c.Value).ToList();
        return componentTypes.Contains(attribute.Parent.Name.LocalName);
    }

    /// <summary>
    /// Determines if the provided object is a attribute or property is a data type reference, for which we need to
    /// reindex references.
    /// </summary>
    private static bool IsDataTypeProperty(object sender)
    {
        if (sender is not XAttribute attribute) return false;
        if (attribute.Name.LocalName is not L5XName.DataType) return false;
        if (attribute.Parent is null) return false;
        var componentTypes = ComponentType.All().Select(c => c.Value).ToList();
        return componentTypes.Contains(attribute.Parent.Name.LocalName);
    }

    /// <summary>
    /// Determines if the provided object is a a logix code element, for which we need to reindex references.
    /// </summary>
    private static bool IsCodeElement(object sender)
    {
        if (sender is not XElement element) return false;
        var contentTypes = RoutineType.All().Select(r => r.ContentName).ToList();
        return element.Ancestors().Any(a => contentTypes.Contains(a.Name.LocalName));
    }

    /// <summary>
    /// Determines if the provided object is a attribute or property of a logix code element, for which we need to
    /// reindex references.
    /// </summary>
    private static bool IsCodeProperty(object sender)
    {
        if (sender is not XAttribute attribute) return false;
        if (attribute.Name.LocalName is not
            (L5XName.Operand or L5XName.Argument or L5XName.Routine or L5XName.Type or L5XName.Name)) return false;
        return attribute.Parent is not null && IsCodeElement(attribute.Parent);
    }

    /// <summary>
    /// Merges all top level containers and their immediate child elements between the current L5X content and the
    /// provided L5X content. Will overwrite if specified.
    /// </summary>
    /// <param name="l5X">The L5X element to merge with the current target element.</param>
    /// <param name="overwrite">A flag to indicate whether to overwrite child elements of matching name.</param>
    private void MergeContent(L5X l5X, bool overwrite)
    {
        if (l5X is null) throw new ArgumentNullException(nameof(l5X));

        var containerPairs = GetContainers()
            .Join(l5X.GetContainers(), e => e.Name, e => e.Name, (a, b) => new { a, b })
            .ToList();

        foreach (var pair in containerPairs)
            MergeContainers(pair.a, pair.b, overwrite);
    }

    /// <summary>
    /// Given to top level containers, adds or replaces all child elements matching based on the logix name of the elements.
    /// </summary>
    private static void MergeContainers(XContainer target, XContainer source, bool overwrite)
    {
        foreach (var element in source.Elements())
        {
            var match = target.Elements().FirstOrDefault(e => e.LogixName() == element.LogixName());

            if (match is null)
            {
                target.Add(element);
                continue;
            }

            if (overwrite)
                match.ReplaceWith(element);
        }
    }

    /// <summary>
    /// Creates a new default content element for a new instance of an L5X file given the provided target name and type.
    /// </summary>
    private static XElement NewContent(string targetName, string targetType, Revision? softwareRevision)
    {
        var content = new XElement(L5XName.RSLogix5000Content);
        content.Add(new XAttribute(L5XName.SchemaRevision, new Revision()));
        if (softwareRevision is not null) content.Add(new XAttribute(L5XName.SoftwareRevision, softwareRevision));
        content.Add(new XAttribute(L5XName.TargetName, targetName));
        content.Add(new XAttribute(L5XName.TargetType, targetType));
        content.Add(new XAttribute(L5XName.ContainsContext, targetType != nameof(Controller)));
        content.Add(new XAttribute(L5XName.Owner, Environment.UserName));
        content.Add(new XAttribute(L5XName.ExportDate, DateTime.Now.ToString(DateTimeFormat)));

        return content;
    }

    /// <summary>
    /// If no root controller element exists, adds new context controller and moves all root elements into that controller
    /// element. Then adds missing top level containers to ensure consistent structure of the root L5X.
    /// </summary>
    private void NormalizeContent()
    {
        if (_content.Element(L5XName.Controller) is null)
        {
            var context = new XElement(L5XName.Controller, new XAttribute(L5XName.Use, Use.Context));
            context.Add(_content.Elements());
            _content.RemoveNodes();
            _content.Add(context);
        }

        var controller = _content.Element(L5XName.Controller)!;

        foreach (var container in from container in Containers
                 let existing = controller.Element(container)
                 where existing is null
                 select container)
        {
            controller.Add(new XElement(container));
        }
    }

    /// <summary>
    /// Triggered when any content of the L5X is about to change. We need to know if the object changing is an element
    /// we are maintaining state for in the component or reference index. If so, we need to perform the necessary actions.
    /// Prior to the object changing and if the change action is a remove or value change, we need to remove the applicable
    /// components or references from the index. This is because after the object has changed we no longer have access
    /// to the previous state.
    /// </summary>
    private void OnContentChanging(object sender, XObjectChangeEventArgs e)
    {
        if (e.ObjectChange is XObjectChange.Remove)
        {
            if (IsComponentElement(sender)) RemoveComponent((XElement)sender);
            if (IsCodeElement(sender)) RemoveReferences((XElement)sender);
        }

        if (e.ObjectChange is not XObjectChange.Value) return;

        if (IsNameProperty(sender)) RemoveComponent(((XAttribute)sender).Parent!);
        if (IsDataTypeProperty(sender))
        {
            var attribute = (XAttribute)sender;
            var reference = new CrossReference(attribute.Parent!, L5XName.DataType, attribute.Value);
            RemoveReference(reference);
        }

        if (IsCodeProperty(sender)) RemoveReferences(((XAttribute)sender).Parent!);
    }

    /// <summary>
    /// Triggered when any content of the L5X has changed.  We need to know if the object that changed is an element
    /// we are maintaining state for in the component or reference index. If so, we need to perform the necessary actions.
    /// Once the object has changed, the sender will hold the new state. If the change action is an add or value change,
    /// and the element or property value is one that would refer to an indexed object, we will update the state of the index
    /// to ensure consistency.
    /// </summary>
    private void OnContentChanged(object sender, XObjectChangeEventArgs e)
    {
        if (e.ObjectChange is XObjectChange.Add)
        {
            if (IsComponentElement(sender)) AddComponent((XElement)sender);
            if (IsCodeElement(sender)) AddReferences((XElement)sender);
        }

        if (e.ObjectChange is not XObjectChange.Value) return;

        if (IsNameProperty(sender)) AddComponent(((XAttribute)sender).Parent!);
        if (IsDataTypeProperty(sender))
        {
            var attribute = (XAttribute)sender;
            var reference = new CrossReference(attribute.Parent!, attribute.Value, L5XName.DataType);
            AddReference(reference);
        }

        if (IsCodeProperty(sender)) AddReferences(((XAttribute)sender).Parent!);
    }

    /// <summary>
    /// Handles removing a component matching the current attached element from the index. This requires the element
    /// to be attached to the L5X tree for it to determine the scope of the element. 
    /// </summary>
    private void RemoveComponent(XElement element)
    {
        var key = new ComponentKey(element.Name.LocalName, element.LogixName());
        var scope = Scope.ScopeName(element);

        if (!_componentIndex.TryGetValue(key, out var components)) return;

        if (components.Count == 1)
        {
            _componentIndex.Remove(key);
            return;
        }

        components.Remove(scope);
    }

    /// <summary>
    /// Handles removing the provided reference from the index. If only a single reference exists for the provided key,
    /// the entire reference is removed, otherwise we iterate the references and remove all that match the provided
    /// reference's location and type.
    /// </summary>
    private void RemoveReference(CrossReference reference)
    {
        if (!_referenceIndex.TryGetValue(reference.ComponentKey, out var results)) return;
        if (results.Count == 1)
        {
            _referenceIndex.Remove(reference.ComponentKey);
            return;
        }

        results.RemoveAll(r => r.IsSame(reference));
    }

    /// <summary>
    /// Removes the provided collection of references. This is a convenience method to remove multiple references.
    /// </summary>
    private void RemoveReferences(IEnumerable<CrossReference> references)
    {
        foreach (var reference in references)
        {
            RemoveReference(reference);
        }
    }

    /// <summary>
    /// Handles removing all references from the index that are associated with the provided element.
    /// This is a convenience method since we need to parse the element as an <see cref="ILogixReferencable"/> to
    /// obtain the references to remove.
    /// </summary>
    private void RemoveReferences(XElement element)
    {
        if (LogixSerializer.Deserialize(element) is not ILogixReferencable referencable) return;
        var references = referencable.References().ToList();
        RemoveReferences(references);
    }

    /// <summary>
    /// Create document, adds default declaration, and saves the current L5X content to the specified file name.
    /// </summary>
    /// <param name="fileName">A string that contains the name of the file.</param>
    private void SaveContent(string fileName)
    {
        //This will sanitize containers that were perhaps added when normalizing that went unused.
        foreach (var container in GetContainers().Where(c => !c.HasElements))
            container.Remove();

        var declaration = new XDeclaration("1.0", "UTF-8", "yes");
        var document = new XDocument(declaration);
        document.Add(_content);
        document.Save(fileName);
    }

    #endregion
}